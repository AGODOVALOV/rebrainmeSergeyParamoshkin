1. Узнаем отличие постоянной памяти компьютера от оперативной и как можно ускорить приложение используя кэширование в Key-Value базе данны.
2. Научимся подключать профилировщик к приложению и использовать его.

## Память компьютера

Память компьютера разделяют на оперативную (RAM) и постоянную (SSD, HDD).

Основные отличия оперативной памяти от постоянной:

- Зависимость от питания (оперативная память очищается при перезапуске компьютера)
- Скорость доступа (скорость чтения и записи оперативной памяти значительно выше)

## Скорость ответа сервера

Скорость ответа сервера (Server Response Time, SRT) - это время от отправки запроса (например нажатия на ссылку в браузере) до ответа сервера.

Что влияет на SRT?

- Медленная логика приложения (сложные вычисления)
- Долгие ответы от хранилища (база данных)

Кэширование может помочь решить обе эти проблемы.

## In-Memory кэширование

In-memory кэширование это техника, при которой приложение хранит данные, полученные из внешних источников (БД) или в результате долгих вычислений, в оперативной памяти для возможности быстрого их получения в дальнейшем.

Поскольку доступ к данным которые лежат в оперативной памяти является самым быстрым, это позволяет значительно увеличить скорость работы программы.

In-Memory кеширование может быть реализовано как в самом приложении (от map до стороннего пакета для кэширования с поддержкой eviction-политик) так и с помощью внешнего Key-Value хранилища.

## Key-Value в качестве кэша

Key-Value базы данных так же могут быть использованы в качестве кэша данных если данные читаются чаще чем обновляются. Хотя они медленней кэша в самом приложении (как минимум за счёт накладных расходов на транспорт данных), они всё же имеют ряд преимуществ:

- Не зависят от работы приложения, что позволяет использовать их как кеш для нескольких разных приложений (или экземпляров одного приложения)
- По той же причине ускоряется запуск и/или первое время работы программы, за счёт того что кэш уже наполнен данными (не надо тратить время на заполнение кэша)
- Некоторые реализации позволяют включить запись на диск

## Шаблоны использования кэша

Существую несколько распространённых шаблонов для реализации кэширования:

- Кэш на стороне (Cache Aside). При чтении логика приложения сначала обращается в кэш за данными и в случае неудачи идёт в БД (или запускает вычисления), после чего записывает результат в кэш
- Сквозное чтение (Read-through). Отличие от Cache Aside в разделении ответственности: при чтении логика приложения обращается только к кэшу, обращение к БД (или запуск вычислений) происходит внутри кэша
- Сквозная запись (Write-through). Запись в кэш приводит к синхронной записи в БД
- Запись после (Write-behind). Сначала происходит запись в кэш, после асинхронная запись в БД (минус - несогласованность данных при ошибке записи в БД)

## Вытеснение данных из кэша (Eviction Policies)

Поскольку оперативная память приложения имеет меньший размер чем БД, необходимо контролировать размер кэша.
В зависимости от данных возможны разные способы очищения кэша, вот некоторые из них:

- Least recently used (LRU): вытеснение давно не используемых данных
- Most recently used (MRU): вытеснение наиболее недавно использовавшихся данных. Полезно в случаях когда известно что недавно встреченный элемент маловероятно встретится повторно в ближайшем времени (например номер подъезжающего автобуса на остановке)
- Least frequently used (LFU): вытеснение самых не часто используемых, то есть данных которые запрашивались реже всего
- По времени с записи: вытесняются элементы, время записи которых старше какого-то времени
- По времени с чтения: вытесняются элементы, время доступа к которым старше какого-то времени

## Пример с redis

/examples/caching/redis

## Профилирование

Профилирование это важная часть разработки и поддержки приложения. С помощью инструментов профилирования можно найти узкие места приложения, которые нагружают ЦПУ и оперативную память.

В golang существует утилита go tool pprof, которая, вместе с пакетом "net/http/pprof", позволяет увидеть общую картину выполнения приложения.

#### Встраивание профилировщика в приложение

Встраивание профилировщика в приложение производится с помощью пакета "net/http/pprof", который предоставляет набор профилей для анализа приложения в виде http-обработчиков (handler).

``` golang
import "net/http/pprof"

<...>

 r := chi.NewRouter()
 r.Mount("/debug", Profiler())

<...>

func Profiler() http.Handler {
 r := chi.NewRouter()

 r.Get("/", func(w http.ResponseWriter, r *http.Request) {
  http.Redirect(w, r, r.RequestURI+"/pprof/", http.StatusMovedPermanently)
 })
 r.HandleFunc("/pprof", func(w http.ResponseWriter, r *http.Request) {
  http.Redirect(w, r, r.RequestURI+"/", http.StatusMovedPermanently)
 })

    // Получение списка всех профилей
 r.HandleFunc("/pprof/*", pprof.Index)
    // Отображение строки запуска (например: /go-observability-course/examples/caching/redis/__debug_bin)
 r.HandleFunc("/pprof/cmdline", pprof.Cmdline)
    // профиль ЦПУ, в query-параметрах можно указать seconds со значением времени в секундах для снимка (по-умолчанию 30с)
 r.HandleFunc("/pprof/profile", pprof.Profile)
 r.HandleFunc("/pprof/symbol", pprof.Symbol)
    // профиль для получения трассировки (последовательности инструкций) выполнения приложения за время seconds из query-параметров ( по-умолчанию 1с)
 r.HandleFunc("/pprof/trace", pprof.Trace)

 <...>

 return r
}

```

#### Запуск профилирования ЦПУ

Перед запуском go tool pprof нужно как-то нагрузить программу, чтобы накопилась статистика для анализа.

```sh
➜  go-observability-course git:(master) ✗ wrk 'http://localhost:9000/users/b29f95a2-499a-4079-97f5-ff55c3854fcb/articles'
Running 10s test @ http://localhost:9000/users/b29f95a2-499a-4079-97f5-ff55c3854fcb/articles
  2 threads and 10 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     0.93ms    1.23ms   8.42ms   83.40%
    Req/Sec    10.62k     6.36k   20.29k    66.00%
  211442 requests in 10.00s, 78.44MB read
Requests/sec:  21135.53
Transfer/sec:      7.84MB
```

Сразу после предыдущей команды запускаем go tool pprof

```sh
➜  redis git:(master) ✗ go tool pprof http://localhost:9000/debug/pprof/profile\?seconds\=5
Fetching profile over HTTP from http://localhost:9000/debug/pprof/profile?seconds=5
Saved profile in /Users/nshibalov/pprof/pprof.samples.cpu.011.pb.gz
Type: cpu
Time: Aug 21, 2021 at 8:54pm (MSK)
Duration: 5.20s, Total samples = 8.74s (168.15%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof)
```

В открывшемся приложении есть консоль, для того чтобы увидеть граф вызовов надо выполнить команду **web**, после чего откроется браузер с графом.

```sh
(pprof) web
(pprof)
```

На данном графе видно название функций и время затраченное в них. Чтобы получить более детальную информацию, можно выполнить команду weblist с именем функции, например:

```sh
(pprof) weblist GetUserArticles
(pprof)
```

```sh
➜  redis git:(master) ✗ go tool pprof http://localhost:9000/debug/pprof/heap
Fetching profile over HTTP from http://localhost:9000/debug/pprof/heap
Saved profile in /Users/nshibalov/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz
Type: inuse_space
Time: Aug 21, 2021 at 9:29pm (MSK)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) web
